/**
 * file: TC.h - The include file for this library
 *
 * OpenTC.
 *
 * The contents of this file are subject to the OpenTC Open-Source
 * License, Version 1.0 (the ``License''); you may not use
 * this file except in compliance with the License.  You may obtain a
 * copy of the License in the file ``LICENSE.txt'' found in this distribution.
 *
 * Software distributed under the License is distributed on an AS IS basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * 
 * The Creators of OpenTC are:
 *         Abhilasha Bhargav, <bhargav@cs.purdue.edu>
 *         Rahim Sewani, <sewani@cs.purdue.edu>
 *         Sarvjeet Singh, <sarvjeet_s@yahoo.com, sarvjeet@purdue.edu>
 *         Cristina Nita-Rotaru, <crisn@cs.purdue.edu>
 *
 * Contributors:
 *         Chi-Bun Chan, <cbchan@cs.purdue.edu>
 *
 * Copyright (c) 2004 Purdue University.
 * All rights reserved.
 *
 */

#ifndef TC_H
#define TC_H

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <openssl/bn.h>
#include <openssl/evp.h>

#if STDC_HEADERS
#include <stdlib.h>
#endif /*STDC_HEADERS*/

#if HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* All return error codes */

#define TC_NOERROR 0
#define TC_ERROR -1000
#define TC_ALLOC_ERROR -1001
#define TC_NOT_ENOUGH_SIGS -1002
#define TC_BN_ARTH_ERROR -1003

/* Structures used by the library */
  
typedef struct {
  BIGNUM* u;      /* The jacobi normalisation */
  BIGNUM* e;      /* public key */
  BIGNUM* n;      /* public key */

  int l;          /* total number of people */
  int k;          /* threshold */

  BIGNUM* v;      /* verification key */

  BIGNUM** vki;   /* array of verification keys */
  BIGNUM** si;    /* array of secret keys */

  const EVP_MD* Hp;     /* hash pointer */

} TC_DEALER;      /* Output of dealer */


typedef struct  {
  BIGNUM* e; /* public key */
  BIGNUM* n; /* public key */
} TC_PK; /* Key used by the signature verifier */
  

typedef struct  {
  int l;         /* total number of people */
  int k;         /* threshold */
  int mynum;     /* My number = i; = -1  if the person doesn't have si (i.e. its only a combiner 
		  mynum is (index-1) where index is the index used in TC_get_ind() */

  BIGNUM* v;     /* verification key */
  
  BIGNUM* u;     /* The jacobi normalisation */
  BIGNUM* e;     /* public key */
  BIGNUM* n;     /* public key */
  
  BIGNUM** vki;   /* Array of verification keys */
  BIGNUM* si;    /* ith persons secret key -- Can be null */

  const EVP_MD* Hp;    /* hash pointer  */
} TC_IND;        /* The individual Key */     


typedef struct {
  BIGNUM* sig;         /* individual signature */
  BIGNUM* proof_z;     /* Proof */
  BIGNUM* proof_c;     /* Proof */
} TC_IND_SIG;   /* sent by an individual to combiner process */

typedef BIGNUM *TC_SIG; /* The final Signature */


/* Main Functions */

int TC_Combine_Sigs(TC_IND_SIG** ind_sigs, TC_IND *key, BIGNUM *hM, TC_SIG *sig, int checkproof);
  /* TC_Combine_Sigs takes the individual signatures ind_sigs from the group members and tries
     to generate a valid signature on the message hash hM. key is either the individual key
     (generated by TC_get_ind or the combine key (generated by TC_get_combine). The final
     signature (if success) is returned in sig. ind_sigs array is generated by making one or more
     calls to set_tc_sig. The flag checkproof determines whether the proof along with each signature
     is checked or not.

     Return value is TC_NOERROR in case of success, TC_ALLOC_ERROR in case allocation of 
     temporary BIGNUM's failed, TC_BN_ARTH_ERROR in case these was an error while doing
     arthmetic on BIGNUM's, and TC_NOT_ENOUGH_SIGS if ind_sigs does not contain enough
     ( >= threshold) of verified signatures. In all the library functions that returns either
     TC_ALLOC_ERROR or TC_BN_ARTH_ERROR, the error codes and texual messages can be obtained by 
     using openssl > crypto > err(3)
  */

int TC_Combine_Sigs_P1(TC_IND_SIG **ind_sigs, TC_IND *key, BIGNUM *hM, int checkproof, int idx, 
    BIGNUM *wexp, int **pSet_S);
  /* TC_Combine_Sigs_P1 performs the first half of TC_Combine_Sigs. It takes the individual 
     signatures ind_sigs from the group members and tries to generate a partial exponent of w 
     for the individual node idx. key is either the individual key (generated by TC_get_ind or 
     the combine key (generated by TC_get_combine). The partial exponent (if success) is returned
     in wexp, which has to be (allocated and) initialized before calling to this function. 
     In contrast to TC_Combine_Sigs, the Set_S variable is kept external for being 
     later used by TC_Combine_Sigs_P2. A pointer to an external Set_S is passed to this function and 
     memory is allocated internally. ind_sigs array is generated by making one or more
     calls to set_tc_sig. The flag checkproof determines whether the proof along with 
     each signature is checked or not. A following call to TC_Combine_Sigs_P2 is expected in normal
     operations, which will free Set_S. However, if TC_Combine_Sigs_P2 is not invoked, Set_S
     has to be freed externally.

     Return value is TC_NOERROR in case of success, TC_ALLOC_ERROR in case allocation of 
     temporary BIGNUM's failed, TC_BN_ARTH_ERROR in case these was an error while doing
     arthmetic on BIGNUM's, and TC_NOT_ENOUGH_SIGS if ind_sigs does not contain enough
     ( >= threshold) of verified signatures. In all the library functions that returns either
     TC_ALLOC_ERROR or TC_BN_ARTH_ERROR, the error codes and texual messages can be obtained by 
     using openssl > crypto > err(3)
  */
int TC_Combine_Sigs_P2(TC_IND *key, BIGNUM *hM, TC_SIG *sig, BIGNUM *wexps, int *Set_S);
  /* TC_Combine_Sigs_P2 performs the second half of TC_Combine_Sigs. It takes the individual 
     partial exponents of w, passed via wexps, to generate a valid signature on the message hash hM. 
     key is either the individual (generated by TC_get_ind or the combine key (generated by 
     TC_get_combine). The final signature (if success) is returned in sig. Set_S is obtained from 
     TC_Combine_Sigs_P1. Set_S will be freed internally, but wexps will not.

     Return value is TC_NOERROR in case of success, TC_ALLOC_ERROR in case allocation of 
     temporary BIGNUM's failed, TC_BN_ARTH_ERROR in case these was an error while doing
     arthmetic on BIGNUM's, and TC_NOT_ENOUGH_SIGS if ind_sigs does not contain enough
     ( >= threshold) of verified signatures. In all the library functions that returns either
     TC_ALLOC_ERROR or TC_BN_ARTH_ERROR, the error codes and texual messages can be obtained by 
     using openssl > crypto > err(3)
  */


TC_DEALER* TC_generate(int bits, int l, int k, unsigned long e);
  /* TC_generate sets up the threshold signature system by generating the public keys, private keys
     and the verification keys. These individual keys could be extracted from the TC_DEALER struct
     by making calls to TC_get_ind (individual key), TC_get_combine(combine key), TC_get_pub (public
     key). The hash function used for verication can be set by TC_Dealer_setHash (A EVP_md5() has is
     assumed if no hash function is specified). The public key generated will be of 2*bits bits
     (typically bits=128). l is total number of members and k is the threshold. e will be the
     public exponent of the generated key. e is an prime number, typically 3, 17 or 65537. The 
     pseudo random number generater should be seeded using RAND_seed or RAND_add 
     (see openssl > crypto > rand(3) for details) before making call to TC_generate. The 
     TC_DEALER struct should be freed using TC_DEALER_free() to prevent memory leaks.
  
     Return value is TC_NOERROR in case of success, TC_ALLOC_ERROR in case allocation of
     temporary BIGNUM's failed and TC_BN_ARTH_ERROR in case these was an error while doing
     arthmetic on BIGNUM's. In all the library functions that returns either TC_ALLOC_ERROR or 
     TC_BN_ARTH_ERROR, the error codes and texual messages can be obtained by using 
     openssl > crypto > err(3)
  */

TC_IND * TC_read_share(char * file);
  /*  Reads a single secret share from the file pointed to by file */

TC_PK * TC_read_public_key(char* file);
  /*  Reads an RSA public key (e,n) from the file pointed to by file */

void TC_write_shares(TC_DEALER* dealer, char* directory, int site_number );
  /*  Writes shares and RSA public key to the directory pointed to by directory,
      shares are written to "directory/sharek.pem" k=0...n-1, and publickey.pem 
      for the public key */

int TC_Check_Proof(TC_IND *tcind,BIGNUM* hM,TC_IND_SIG* sign, int signum);
  /* TC_Check_Proof checks the proof of correctness sent by individual member. tcind is either the 
     secret individual key or the combine key, hM is hash of the message (which was signed), sign
     is the signature sent by the member, and signum is the member's number who generated "sign"
     (the same number that was used to extract member's key from TC_DEALER). This function is
     called by the TC_Combine_Sigs internally to check all the signatures and may not be normally
     used. But in cases, when you want to detect "mallicious" group members, you can use this
     function to check their proof.

     Return value is 0 if the proof is not valid, 1 if its valid, TC_ALLOC_ERROR in case allocation 
     of temporary BIGNUM's failed and TC_BN_ARTH_ERROR in case these was an error while doing
     arthmetic on BIGNUM's. In all the library functions that returns either TC_ALLOC_ERROR or
     TC_BN_ARTH_ERROR, the error codes and texual messages can be obtained by using
     openssl > crypto > err(3)
  */

int genIndSig(TC_IND *tcind,BIGNUM *hM,TC_IND_SIG* sign, int genproof);
  /* genIndSig generates a signature and proof of correctness on the message hash hM, using 
     tcind as the secret key. The output is placed in sign. sign should already be allocated
     using TC_IND_SIG_new() before passing it to genIndSig. After its used, it can be freed by
     TC_IND_SIG_free to prevent memomy leaks. The pseudo random number generater should be 
     seeded using RAND_seed or RAND_add (see openssl > crypto > rand(3) for details) before 
     making call to this function. The flag genproof determines whether the proof is generated
     along with the signature.
     
     Return value is TC_NOERROR in case of success, TC_ALLOC_ERROR in case allocation
     of temporary BIGNUM's failed and TC_BN_ARTH_ERROR in case these was an error while doing
     arthmetic on BIGNUM's.
  */


int TC_verify(BIGNUM *hM, TC_SIG sig, TC_PK *tcpk);
  /* TC_verify verifies the signature sig (generated using TC_Combine_Sigs) on the message hM
     using the public key tcpk.
     
     Return value is 0 if the signature is not valid, 1 if its valid, TC_ALLOC_ERROR in case allocation
     of temporary BIGNUM's failed and TC_BN_ARTH_ERROR in case these was an error while doing
     arthmetic on BIGNUM's.
  */

/* Helper functions on structs defined. */

TC_DEALER *TC_DEALER_new(void);
  /* Allocates and returns a new TC_DEALER struct. Returns NULL on error */

void TC_DEALER_free(TC_DEALER *tc);
  /* Frees the TC_DEALER struct generated by TC_DEALER_new or TC_generate */

void TC_DEALER_print(TC_DEALER *tc);
  /* Prints TC_DEALER struct */

int TC_Dealer_setHash (TC_DEALER *tcd,unsigned short hashpointer);
  /* Changes the default hash function (EVP_md5()) used for verification by tcd */

TC_IND *TC_get_ind(int index,TC_DEALER *tcd);
  /* Extracts the index member's private key from tcd. Should be freed using TC_IND_free to
   prevent memory leak */

TC_PK *TC_get_pub (TC_DEALER *tcd);
  /* Extracts the public key from tcd. Should be freed using TC_PK_free to prevent memory leaks */

TC_IND *TC_get_combine(TC_DEALER *tcd);
  /* Extracts the combine key from tcd. This key is similar the ind key except
     that it doesn't have the secret share and hence can only be used for combining
     and not signing the individual messages. Should be freed using TC_IND_free to prevent memory
     leaks
  */

void TC_PK_free(TC_PK *tcpk);
  /* Frees memory used by tcpk */

void TC_IND_free(TC_IND *tcind);
  /* Frees tcind. tcind can be a secret/private key or a combine key */

TC_IND_SIG *TC_IND_SIG_new();
  /* Allocates and returns a new TC_IND_SIG struct. Should be freed using TC_IND_SIG_free */

void TC_PK_Print(TC_PK *pk);
  /* Prints pk */

void TC_IND_Print(TC_IND *ind);
  /* Prints ind */

void TC_IND_SIG_Print(TC_IND_SIG *sig);
  /* Prints sig */

TC_IND_SIG **TC_SIG_Array_new(int l);
  /* Returns a new array of size l(=total number of members), which is to be used as 
     target of one or more set_TC_sig calls to set the individual signatures, and finally
     it is passed to TC_Combine to combine all the individual signatures
  */

void set_TC_SIG(int index, TC_IND_SIG* si,TC_IND_SIG** sigs);
  /* Adds the individual signature si to index slot of sigs. Index should be number of member
     whose signature is si. sigs should be allocated using TC_SIG_Array_new before making this
     call. After sigs is used in TC_Combine, it should be freed using TC_SIG_ARRAY_free to
     prevent memory leaks
*/

void TC_IND_SIG_free(TC_IND_SIG *a);
  /* Frees TC_IND_SIG a */


void TC_SIG_Array_free(TC_IND_SIG **a,int l);
  /* Frees TC_IND_SIG **a. l is total number of members */

/* Marshal, Demarshal fucntions */
/* These functions can be used to convert the TC's structs into stream of bytes and convert the
   streams of bytes back into the structs. This is useful if you want to transfer the structs from
   one machine/process to other. The stream of bytes produces is independent of the platform (big
   endian, small endian) and thus can be used to transfer these structures across platforms.
   
   All structs returned by demarshal should be freed by corresponding calls to free()
*/

int TC_PK_size(TC_PK *a);
  /* Returns size of byte stream produced by marshaling a */
int TC_PK_marshal(TC_PK *a, unsigned char *buf);
  /* marshals a and stores it in buf. buf should be atleast TC_PK_size(a) long.
     Returns TC_PK_size(a) in case of success, -1 on error 
  */
TC_PK *TC_PK_demarshal(unsigned char *buf);
  /* Demarshals buf and allocates and returns back a TC_PK structure. 
     Returns the struct in case of success, NULL on error (e.g. cannot parse
     buf, cannot allocate TC_PK).
  */

int TC_IND_size(TC_IND *a);
  /* Returns size of byte stream produced by marshaling a */
int TC_IND_marshal(TC_IND *a, unsigned char *buf);
  /* marshals a and stores it in buf. buf should be atleast TC_IND_size(a) long.
     Returns TC_IND_size(a) in case of success, -1 on error
  */
TC_IND *TC_IND_demarshal(unsigned char *buf);
  /* Demarshals buf and allocates and returns back a TC_IND structure.
     Returns the struct in case of success, NULL on error (e.g. cannot parse
     buf, cannot allocate TC_IND).
  */

int TC_IND_SIG_size(TC_IND_SIG *a);
  /* Returns size of byte stream produced by marshaling a */
int TC_IND_SIG_marshal(TC_IND_SIG *a, unsigned char *buf);
  /* marshals a and stores it in buf. buf should be atleast TC_IND_SIG_size(a) long.
     Returns TC_IND_SIG_size(a) in case of success, -1 on error
  */
TC_IND_SIG *TC_IND_SIG_demarshal(unsigned char *buf);
  /* Demarshals buf and allocates and returns back a TC_IND_SIG structure.
     Returns the struct in case of success, NULL on error (e.g. cannot parse
     buf, cannot allocate TC_IND_SIG).
  */

int TC_SIG_size(TC_SIG a);
  /* Returns size of byte stream produced by marshaling a */
int TC_SIG_marshal(TC_SIG a, unsigned char *buf);
  /* marshals a and stores it in buf. buf should be atleast TC_SIG_size(a) long.
     Returns TC_SIG_size(a) in case of success, -1 on error
  */
TC_SIG TC_SIG_demarshal(unsigned char *buf);
  /* Demarshals buf and allocates and returns back a TC_SIG structure.
     Returns the struct in case of success, NULL on error (e.g. cannot parse
     buf, cannot allocate TC_SIG).
  */


#ifdef  __cplusplus
}
#endif
#endif
